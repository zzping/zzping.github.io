<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>运行时数据区域之 - Java 堆 | 南风知我意</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/images/nf.png">
    <meta name="description" content="后端开发 南风知我意的个人网站">
    
    <link rel="preload" href="/assets/css/0.styles.d2a44814.css" as="style"><link rel="preload" href="/assets/js/app.fa9b922e.js" as="script"><link rel="preload" href="/assets/js/2.25cc5d58.js" as="script"><link rel="preload" href="/assets/js/43.3f4c39b8.js" as="script"><link rel="prefetch" href="/assets/js/10.a87e3e41.js"><link rel="prefetch" href="/assets/js/11.0364ff90.js"><link rel="prefetch" href="/assets/js/12.311eca75.js"><link rel="prefetch" href="/assets/js/13.0157e368.js"><link rel="prefetch" href="/assets/js/14.12ac4ad9.js"><link rel="prefetch" href="/assets/js/15.356aa848.js"><link rel="prefetch" href="/assets/js/16.bc1151d9.js"><link rel="prefetch" href="/assets/js/17.def4874d.js"><link rel="prefetch" href="/assets/js/18.e350c724.js"><link rel="prefetch" href="/assets/js/19.e83e1d7c.js"><link rel="prefetch" href="/assets/js/20.c97de166.js"><link rel="prefetch" href="/assets/js/21.d2f7bd5c.js"><link rel="prefetch" href="/assets/js/22.41adaee0.js"><link rel="prefetch" href="/assets/js/23.799354b2.js"><link rel="prefetch" href="/assets/js/24.95fca6d6.js"><link rel="prefetch" href="/assets/js/25.465e8b94.js"><link rel="prefetch" href="/assets/js/26.16f7559c.js"><link rel="prefetch" href="/assets/js/27.ff4ffb1f.js"><link rel="prefetch" href="/assets/js/28.044518d6.js"><link rel="prefetch" href="/assets/js/29.dd693b24.js"><link rel="prefetch" href="/assets/js/3.ac93ca0a.js"><link rel="prefetch" href="/assets/js/30.962c7f0b.js"><link rel="prefetch" href="/assets/js/31.ed040a46.js"><link rel="prefetch" href="/assets/js/32.173e5f2d.js"><link rel="prefetch" href="/assets/js/33.02ea8a18.js"><link rel="prefetch" href="/assets/js/34.bb262992.js"><link rel="prefetch" href="/assets/js/35.896e9f41.js"><link rel="prefetch" href="/assets/js/36.1ddb7248.js"><link rel="prefetch" href="/assets/js/37.334aca7d.js"><link rel="prefetch" href="/assets/js/38.c0b524c3.js"><link rel="prefetch" href="/assets/js/39.1fa89074.js"><link rel="prefetch" href="/assets/js/4.ffc5bef0.js"><link rel="prefetch" href="/assets/js/40.d6313086.js"><link rel="prefetch" href="/assets/js/41.3f1e2bbd.js"><link rel="prefetch" href="/assets/js/42.29fd018f.js"><link rel="prefetch" href="/assets/js/44.7ecbe764.js"><link rel="prefetch" href="/assets/js/45.bec8ffa7.js"><link rel="prefetch" href="/assets/js/46.4d6373ca.js"><link rel="prefetch" href="/assets/js/47.a2c38019.js"><link rel="prefetch" href="/assets/js/48.36ff8bd5.js"><link rel="prefetch" href="/assets/js/49.d7349f0b.js"><link rel="prefetch" href="/assets/js/5.48532fea.js"><link rel="prefetch" href="/assets/js/50.3da1f291.js"><link rel="prefetch" href="/assets/js/51.45ef4844.js"><link rel="prefetch" href="/assets/js/52.8986512b.js"><link rel="prefetch" href="/assets/js/53.749813e1.js"><link rel="prefetch" href="/assets/js/54.96f2a134.js"><link rel="prefetch" href="/assets/js/55.4879e422.js"><link rel="prefetch" href="/assets/js/56.e8428beb.js"><link rel="prefetch" href="/assets/js/57.ca777ff0.js"><link rel="prefetch" href="/assets/js/58.dbb557db.js"><link rel="prefetch" href="/assets/js/59.df72912c.js"><link rel="prefetch" href="/assets/js/6.5eff19f1.js"><link rel="prefetch" href="/assets/js/60.d1ef93aa.js"><link rel="prefetch" href="/assets/js/61.b14ca761.js"><link rel="prefetch" href="/assets/js/62.2b179e3c.js"><link rel="prefetch" href="/assets/js/63.2f9c3889.js"><link rel="prefetch" href="/assets/js/64.9aa6d939.js"><link rel="prefetch" href="/assets/js/65.566da386.js"><link rel="prefetch" href="/assets/js/66.ce6ae55d.js"><link rel="prefetch" href="/assets/js/67.ba64f924.js"><link rel="prefetch" href="/assets/js/68.bfc2523e.js"><link rel="prefetch" href="/assets/js/69.1df26faa.js"><link rel="prefetch" href="/assets/js/7.100b5646.js"><link rel="prefetch" href="/assets/js/70.2063729c.js"><link rel="prefetch" href="/assets/js/71.ec1b8104.js"><link rel="prefetch" href="/assets/js/72.324f3a5e.js"><link rel="prefetch" href="/assets/js/73.17c953d3.js"><link rel="prefetch" href="/assets/js/74.0445d80d.js"><link rel="prefetch" href="/assets/js/75.d323dbb7.js"><link rel="prefetch" href="/assets/js/76.01731c02.js"><link rel="prefetch" href="/assets/js/77.040d470d.js"><link rel="prefetch" href="/assets/js/78.33374f69.js"><link rel="prefetch" href="/assets/js/79.5b3d3b01.js"><link rel="prefetch" href="/assets/js/8.298793bd.js"><link rel="prefetch" href="/assets/js/80.3d4ad376.js"><link rel="prefetch" href="/assets/js/81.7fa4543b.js"><link rel="prefetch" href="/assets/js/82.31832c90.js"><link rel="prefetch" href="/assets/js/83.291a632f.js"><link rel="prefetch" href="/assets/js/84.3efd8628.js"><link rel="prefetch" href="/assets/js/85.27beb273.js"><link rel="prefetch" href="/assets/js/86.d5228a1d.js"><link rel="prefetch" href="/assets/js/87.cad2873f.js"><link rel="prefetch" href="/assets/js/88.76fdf951.js"><link rel="prefetch" href="/assets/js/89.a9d71c3d.js"><link rel="prefetch" href="/assets/js/9.04671bc7.js"><link rel="prefetch" href="/assets/js/90.da55c751.js"><link rel="prefetch" href="/assets/js/91.0b29096c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d2a44814.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">南风知我意</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/java-core/exception.html" class="nav-link">
  Java核心基础
</a></div><div class="nav-item"><a href="/jvm/structure.html" class="nav-link">
  JVM学习
</a></div><div class="nav-item"><a href="/mybatis/mybatis-overview.html" class="nav-link">
  Mybatis
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Spring全家桶" class="dropdown-title"><span class="title">Spring全家桶</span> <span class="arrow down"></span></button> <button type="button" aria-label="Spring全家桶" class="mobile-dropdown-title"><span class="title">Spring全家桶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/spring-all/spring-framework/ioc-interface.html" class="nav-link">
  Spring Framework
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="拥抱云原生" class="dropdown-title"><span class="title">拥抱云原生</span> <span class="arrow down"></span></button> <button type="button" aria-label="拥抱云原生" class="mobile-dropdown-title"><span class="title">拥抱云原生</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cloud-native/cloud-native-concepts/" class="nav-link">
  云原生概念
</a></li><li class="dropdown-item"><!----> <a href="/cloud-native/docker/docker-overview/" class="nav-link">
  Docker
</a></li><li class="dropdown-item"><!----> <a href="/cloud-native/kubernetes/" class="nav-link">
  Kubernetes
</a></li><li class="dropdown-item"><!----> <a href="/cloud-native/devops/" class="nav-link">
  DevOps
</a></li></ul></div></div><div class="nav-item"><a href="/frontend/vue/vue-overview.html" class="nav-link">
  前端 - Vue
</a></div><div class="nav-item"><a href="/other/java8/why-java8.html" class="nav-link">
  零散知识
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/java-core/exception.html" class="nav-link">
  Java核心基础
</a></div><div class="nav-item"><a href="/jvm/structure.html" class="nav-link">
  JVM学习
</a></div><div class="nav-item"><a href="/mybatis/mybatis-overview.html" class="nav-link">
  Mybatis
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Spring全家桶" class="dropdown-title"><span class="title">Spring全家桶</span> <span class="arrow down"></span></button> <button type="button" aria-label="Spring全家桶" class="mobile-dropdown-title"><span class="title">Spring全家桶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/spring-all/spring-framework/ioc-interface.html" class="nav-link">
  Spring Framework
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="拥抱云原生" class="dropdown-title"><span class="title">拥抱云原生</span> <span class="arrow down"></span></button> <button type="button" aria-label="拥抱云原生" class="mobile-dropdown-title"><span class="title">拥抱云原生</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cloud-native/cloud-native-concepts/" class="nav-link">
  云原生概念
</a></li><li class="dropdown-item"><!----> <a href="/cloud-native/docker/docker-overview/" class="nav-link">
  Docker
</a></li><li class="dropdown-item"><!----> <a href="/cloud-native/kubernetes/" class="nav-link">
  Kubernetes
</a></li><li class="dropdown-item"><!----> <a href="/cloud-native/devops/" class="nav-link">
  DevOps
</a></li></ul></div></div><div class="nav-item"><a href="/frontend/vue/vue-overview.html" class="nav-link">
  前端 - Vue
</a></div><div class="nav-item"><a href="/other/java8/why-java8.html" class="nav-link">
  零散知识
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JVM 整体三层结构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>内存与垃圾回收篇</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jvm/runtime-data-area-overview.html" class="sidebar-link">运行时数据区域概述</a></li><li><a href="/jvm/pc-register.html" class="sidebar-link">运行时数据区域之 - 程序计数器</a></li><li><a href="/jvm/java-virtual-machine-stack.html" class="sidebar-link">运行时数据区域之 - Java 虚拟机栈</a></li><li><a href="/jvm/native-method-stack.html" class="sidebar-link">运行时数据区域之 - 本地方法栈</a></li><li><a href="/jvm/java-heap.html" aria-current="page" class="active sidebar-link">运行时数据区域之 - Java 堆</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jvm/java-heap.html#java-堆的概述" class="sidebar-link">Java 堆的概述</a></li><li class="sidebar-sub-header"><a href="/jvm/java-heap.html#堆内存细分" class="sidebar-link">堆内存细分</a></li><li class="sidebar-sub-header"><a href="/jvm/java-heap.html#设置堆内存大小与oom" class="sidebar-link">设置堆内存大小与OOM</a></li><li class="sidebar-sub-header"><a href="/jvm/java-heap.html#新生代和老年代以及相关参数" class="sidebar-link">新生代和老年代以及相关参数</a></li><li class="sidebar-sub-header"><a href="/jvm/java-heap.html#图解对象分配的过程" class="sidebar-link">图解对象分配的过程</a></li><li class="sidebar-sub-header"><a href="/jvm/java-heap.html#minorgc、majorgc、fullgc" class="sidebar-link">MinorGC、MajorGC、FullGC</a></li><li class="sidebar-sub-header"><a href="/jvm/java-heap.html#堆空间分代思想" class="sidebar-link">堆空间分代思想</a></li><li class="sidebar-sub-header"><a href="/jvm/java-heap.html#堆空间中每个线程私有的缓冲区-tlab" class="sidebar-link">堆空间中每个线程私有的缓冲区 - TLAB</a></li><li class="sidebar-sub-header"><a href="/jvm/java-heap.html#堆空间相关参数设置小结" class="sidebar-link">堆空间相关参数设置小结</a></li><li class="sidebar-sub-header"><a href="/jvm/java-heap.html#堆是分配对象的唯一选择吗" class="sidebar-link">堆是分配对象的唯一选择吗？</a></li></ul></li><li><a href="/jvm/method-area.html" class="sidebar-link">运行时数据区域之 - 方法区</a></li><li><a href="/jvm/execution-engine.html" class="sidebar-link">执行引擎</a></li><li><a href="/jvm/gc-overview.html" class="sidebar-link">垃圾回收概述</a></li><li><a href="/jvm/gc-algorithm.html" class="sidebar-link">垃圾回收相关算法</a></li><li><a href="/jvm/gc-concepts.html" class="sidebar-link">垃圾回收相关概念</a></li><li><a href="/jvm/gc-er.html" class="sidebar-link">垃圾回收器</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>字节码与类的加载篇</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="运行时数据区域之-java-堆"><a href="#运行时数据区域之-java-堆" class="header-anchor">#</a> 运行时数据区域之 - Java 堆</h1> <h2 id="java-堆的概述"><a href="#java-堆的概述" class="header-anchor">#</a> Java 堆的概述</h2> <blockquote><p>对于 Java 应用程序来说，Java 堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例。</p> <p>Java 世界里几乎所有的对象实例都在这里分配（栈上分配、标量替换）。</p> <p>根据《Java 虚拟机规范》的规定，Java 堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p> <p>从内存分配的角度看，所有线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），用以提高对象分配时的效率。</p></blockquote> <h2 id="堆内存细分"><a href="#堆内存细分" class="header-anchor">#</a> 堆内存细分</h2> <p>为了更好的支持对象分配和垃圾收集，Java 堆内存可以细分为： <code>新生代</code>、<code>老年代</code> ，默认为 1：2</p> <p>新生代被细分为 Eden 区和两个 Survivor 区（from、to），默认比例 eden : from : to = 8:1:1</p> <p><img src="/images/jvm/%E5%A0%86%E7%A9%BA%E9%97%B4%E7%BB%86%E5%88%86.png" alt="堆内存细分"></p> <h2 id="设置堆内存大小与oom"><a href="#设置堆内存大小与oom" class="header-anchor">#</a> 设置堆内存大小与OOM</h2> <p><strong>（1）如何设置和查看堆内存大小</strong></p> <blockquote><p>Java 堆既可以被实现成固定大小的，也可以是可扩展的。不过当前主流的 Java 虚拟机都是按照可扩展来实现的，通过 -Xms、-Xmx 参数设置堆空间的内存大小。Java 堆的大小在 JVM 启动的时候就已经设定好了。</p> <ul><li><code>-Xms： 设置堆内存的初始大小，等价于 -XX:InitialHeadpSize，默认值为物理电脑内存/64</code></li> <li><code>-Xmx： 设置堆内存的最大内存，等价于 -XX:MaxHeapSize，默认值为物理电脑内存/4</code></li></ul> <hr> <p>查看堆空间大小和各个参数的值：</p> <p>（1）方式一： 加参数 -XX:PrintGCDetails</p> <p>（2）方式二： jps 查看进程号，然后 jstat -gc 进程的pid</p> <hr> <p>如果在 Java 堆内没有内存可以完成实例分配，并且堆也无法再扩展时，Java 虚拟机将会抛出 OutOfMemoryError 异常。</p> <blockquote><p>注意：在通常情况下，服务器项目在运行过程中，堆空间会不断的收缩与扩张，势必会造成不必要的系统压力。
所以在生产环境中，<code>JVM</code>的<code>Xms</code>和<code>Xmx</code>要设置成一样的，能够避免<code>GC</code>在调整堆大小带来的不必要的压力。</p></blockquote></blockquote> <p><strong>（2）OOM 举例</strong></p> <blockquote><p><strong>注意： OOM 总共有8种情况，Java heap space 只是其中的一种 OOM</strong></p> <p><img src="/images/jvm/OOM1.png" alt="oom1"></p></blockquote> <h2 id="新生代和老年代以及相关参数"><a href="#新生代和老年代以及相关参数" class="header-anchor">#</a> 新生代和老年代以及相关参数</h2> <p>Java 堆可以分为新生代和老年代，其中新生代又分为 Eden 和两个 Suvivor（from、to） 区，示意图如下：</p> <p><img src="/images/jvm/%E5%A0%86%E7%A9%BA%E9%97%B4%E7%BB%86%E5%88%86.png" alt="新生代和老年代"></p> <p>（1）设置堆空间中新生代和老年代的大小比例： -XX:NewRation=2</p> <blockquote><p>-XX:NewRatio=2， 默认老年代和新生代为2 : 1，即新生代占整个堆空间的1/3，老年代占整个堆空间的2/3。</p> <p>-XX:NewRatio=4， 表示老年代和新生代为4 : 1，即新生代占1/5，老年代占4/5。</p> <p>-XX:NewRatio 参数官方文档：https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</p> <p><code>两种方式设置新生代和老年代的大小：</code></p> <p>（1）-Xms、-Xmx、-XXNewRatio</p> <p>（2）-Xms、-Xmx、-Xmn（设置新生代内存初始值和最大值）</p> <p><code>同时设置了 -XXNewRatio 和 -Xmn 的话, 则是以 -Xmn 为准</code></p></blockquote> <p>（2）设置新生代中 Eden 和 Survivor 的大小比例： -XX:SurvivorRatio=8</p> <blockquote><p>-XX:SurvivorRatio=8， 默认值为8，表示新生代中 Eden 和 两个 Survivor 区的比例。</p></blockquote> <p>（3）几乎所有的对象都是在 Eden 区被 new 出来的</p> <blockquote><p>几乎所有的对象都是在 Eden 区被 new 出来的</p> <p>IBM 公司的专门研究表明，新生代中 80% 的对象都是 “朝生夕死”的。</p></blockquote> <p>（4）设置新生代内存大小： -Xmn</p> <blockquote><p>官方资料搜索 -Xmn： <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html" target="_blank" rel="noopener noreferrer">-Xmn<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Instead of the <code>-Xmn</code> option to set both the initial and maximum size of the heap for the young generation, you can use <code>-XX:NewSize</code> to set the initial size and <code>-XX:MaxNewSize</code> to set the maximum size.</p></blockquote> <h2 id="图解对象分配的过程"><a href="#图解对象分配的过程" class="header-anchor">#</a> 图解对象分配的过程</h2> <p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。在堆空间中给一个新对象分配内存的过程如下：</p> <p>1、new 的对象先放到 Eden 区域，此区域有大小限制。</p> <p>2、当 Eden 区空间放满了，并且还需要创建新的对象时，将会对 Eden 区域进行垃圾回收（Minor GC），将 Eden 区域中不再被其他对象所引用的对象进行销毁，然后再加载要创建的新对象放到 Eden 区域，最后将伊甸园中的剩余对象移动到 s0 区域。</p> <p>3、如果再次出发垃圾回收，此使上次幸存下来的放到 s0 区域的，如果还没有被回收，就会放到 s1 区域。</p> <p>4、如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</p> <p>5、啥时候能去养老区呢？可以设置次数（-Xx:MaxTenuringThreshold= N）。默认是15次。</p> <p>6、在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。</p> <p>7、若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</p> <blockquote><p>关于垃圾回收： 频繁在新生代收集、很少在老年代收集、几乎不在永久代 / 元空间进行收集</p></blockquote> <h2 id="minorgc、majorgc、fullgc"><a href="#minorgc、majorgc、fullgc" class="header-anchor">#</a> MinorGC、MajorGC、FullGC</h2> <blockquote><p>相关文章： <a href="https://www.zhihu.com/question/41922036" target="_blank" rel="noopener noreferrer">Major GC和 Full GC 的区别是什么<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>JVM 在进行 GC 时，并不是每次都对三个区域（新生代、老年代、方法区），大部分时候回收的都是新生代。</p> <p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域分为了两大类：</p> <ul><li>部分收集（Partial GC）：并不对整个 Java 对进行垃圾收集。
<ul><li>新生代收集（Minor GC / Young GC）： 只对生代进行垃圾收集</li> <li>老年代收集（Major GC / Old GC）： 只对老年代进行垃圾收集，<code>只有 CMS 收集器会有这个模式</code></li> <li>混合收集（Mixed GC）： 收集整个新生代和部分老年代，<code>只有 G1 收集器会有这种模式</code></li></ul></li> <li>整堆收集（Full GC）：针对整个 Java 堆和方法区都进行垃圾收集。</li></ul> <hr> <p><strong>（1）Minor GC</strong></p> <p>Minor GC： 也称为 Young GC，指的是只针对新生代的垃圾收集。每次 Minor GC 都会清理新生代的内存。Minor GC 会引发 STW（Stop The World），但是通常时间都很短暂，影响并不大。</p> <p><code>MinorGC 触发条件</code>：</p> <p>1、当新生代的 Eden 区域满了，这时候还需要将新的对象分配到 Eden 区域</p> <p>2、当新生代的 Eden 区域还没满，但是将要分配的新的对象大小大于 Eden 区域剩下的内存空间</p> <blockquote><p>注意点： Eden 区满了会触发 MinorGC，Survivor 区满了不会触发 MinorGC。</p></blockquote> <p><strong>（2）Major GC</strong></p> <p>Major GC： 也称为 Old GC/Full GC， 指的是发生在老年代的垃圾收集行为。在老年代空间不足时，会触发 Major GC，但是在此之前至少会有一次 Minor GC。</p> <p>Major GC 的时间一般会比 Minor GC 长 10 倍以上，所以 STW 时间也更长。</p> <p>如果 Major GC 后，内存还是不足，就会报 OOM 了。</p> <p><strong>（3）Full GC</strong></p> <p>Full GC： 指的是针对整个 Java 堆（新生代、老年代）和方法区的垃圾收集。</p> <p><code>Full GC 的触发条件</code>：</p> <p>1、调用System.gc时，系统建议执行Full GC，但是不一定会执行 。</p> <p>2、老年代空间不足</p> <p>3、方法区空间不足</p> <p>4、通过 Minor GC 后进入老年代的空间大于老年代的可用内存</p> <p>5、内存空间担保。</p> <blockquote><p>Full GC 在实际开发中是要尽量避免的。调优的主要目的就是为了减少 GC，降低 STW 的时间。</p></blockquote> <h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="header-anchor">#</a> 堆空间分代思想</h2> <p>Java 堆内存是内存管理中重点进行垃圾收集的空间。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以 Java 堆中经常会出现 &quot;新生代&quot;、&quot;老年代&quot; 、&quot;Eden 区&quot;、&quot;Survivor 区&quot; 等名词。之所以有这些区域的划分仅仅是因为一部分垃圾收集器的共同特性或者说设计风格而已，而并非是某个 Java 虚拟机具体实现的内存布局，更不是《Java 虚拟机规范》对 Java 堆的进一步细致划分。</p> <p>在十多年前（以 G1 收集器的出现为分界），作为业界绝对主流的 HotSpot 虚拟机，它内部的收集器全部都是基于 &quot;经典分代&quot; 来进行设计的，需要新生代、老年代收集器搭配才能工作。</p> <p>但是时至今日，垃圾收集技术和10多年前相比已经不可同日而语，HotSpot 虚拟机里面也出现了不采用分代设计的新的垃圾收集器。所以再用之前的分代思想来理解堆空间和方法区其实是有待商榷的。</p> <h2 id="堆空间中每个线程私有的缓冲区-tlab"><a href="#堆空间中每个线程私有的缓冲区-tlab" class="header-anchor">#</a> 堆空间中每个线程私有的缓冲区 - TLAB</h2> <blockquote><p>相关文章： <a href="https://www.zhihu.com/question/56538259" target="_blank" rel="noopener noreferrer">在 TLAB 中创建的对象，如何被其他线程共享<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p><strong>（1）什么是 TLAB</strong></p> <p>TLAB： Thread Local Allocation Buffer，它是在堆空间（新生代的 Eden 区）中为每个线程分配的各自线程私有的一个缓冲区。目的是为了提高对象的分配效率。</p> <p><strong>（2）为什么要有 TLAB</strong></p> <p>我们知道，Java 堆空间是被多个线程所共享的内存区域。一个 JVM 进程中的多个线程都可以访问堆中的共享数据。由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆内存中分配内存创建对象是存在线程安全问题的。为了避免线程安全问题，需要使用加锁机制，进而影响<code>对象分配时的效率</code>。</p> <p>从内存分配而不是垃圾收集的角度来看，所有线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区。这个缓冲区具体是在新生代的 Eden 区中。它就是 TLAB。TLAB 存在的目的是为了提升对象分配的效率，避免多个线程在分配堆空间中内存因为线程安全问题需要加锁（或者CAS）所带来的效率问题。</p> <p>有了 TLAB 之后，往 Eden 区域分配内存给对象时首先会使用 TLAB 这一块空间。因为这一块区域是每个线程私有的，分配对象的时候优先使用且不会因为线程安全问题需要加锁，进而提升了对象分配的效率。</p> <p><strong>（3）TLAB 的相关参数</strong></p> <blockquote><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html" target="_blank" rel="noopener noreferrer">-XX:+UseTLAB<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Enables the use of thread-local allocation blocks (TLABs) in the young generation space. This option is enabled by default. To disable the use of TLABs, specify <code>-XX:-UseTLAB</code>.</p> <hr> <p>验证 TLAB 默认是开启的状态：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TLABTest</span> <span class="token punctuation">{</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token operator">!</span><span class="token punctuation">[</span>TLAB默认开启<span class="token punctuation">]</span><span class="token punctuation">(</span>images<span class="token operator">/</span>验证TLAB是默认开启的状态<span class="token punctuation">.</span>png<span class="token punctuation">)</span>

通过 jps 查看正在运行的程序的进程号，然后通过 jinfo 查看指定参数的值，<span class="token class-name">UseTLAB</span> 前面的<span class="token operator">+</span>表示该参数是被启用的，如果想要关闭 TLAB，只需要添加参数： `<span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">-</span><span class="token class-name">UseTLAB</span>`
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div></blockquote> <p><strong>（4） TLAB 的其他相关问题</strong></p> <p>TLAB 是 Eden 区中为每个线程分配的线程私有的一块缓冲区，但是它只是在为对象 &quot;分配内存&quot; 的这个动作上是线程独占的，在这块区域分配的对象仍然是属于堆空间的，仍然是被多个线程锁共享。详细解释可以参见知乎 R 大的回答： <a href="https://www.zhihu.com/question/56538259" target="_blank" rel="noopener noreferrer">在 TLAB 中创建的对象，如何被其他线程共享？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>从垃圾收集的角度来讲，并没有一个单独收集 TLAB 空间 GC，它和 Eden 中的其他区域都一视同仁的被收集。</p> <blockquote><p>基于 TLAB 的存在，衍生出一个问题： <code>堆空间一定是多个线程共享的吗？</code></p> <p>答案是： 不是，因为还有存在于 Eden 区中的每个线程私有的 TLAB</p></blockquote> <h2 id="堆空间相关参数设置小结"><a href="#堆空间相关参数设置小结" class="header-anchor">#</a> 堆空间相关参数设置小结</h2> <p>官方的 JVM 参数大全： https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</p> <ul><li>-XX:+PrintFlagsInitial  查看所有参数的默认初始值</li> <li>-XX:+PrintFlagsFinal   查看所有参数的最终值，因为可能会修改某些参数值，修改后不再和初始值相同
<ul><li>具体查看某个参数的值： 首先 jps 查看当前程序的进程号，然后 jinfo -flag NewRatio 进程号查看具体值</li></ul></li> <li>-Xms  设置堆空间初始内存，默认为物理内存的 1 / 64</li> <li>-Xmx  设置堆空间最大内存，默认为物理内存的 1 / 4</li> <li>-Xmn  设置新生代的内存大小（初始值和最大值）</li> <li>-XX:NewRatio  设置堆中老年代和新生代的大小比例，默认值为 2 ，即老年代占 2 / 3，新生代占 1 / 3</li> <li>-XX:SuvivorRatio  设置新生代中 Eden 区和 S0/S1 区的比例，默认值为 8</li> <li>-XX:MaxTenuringThreshold  设置新生代垃圾的最大年龄，默认值为 15</li> <li>-XX:+PrintGCDetails  设置输出详细的 GC 日志信息</li> <li>-XX:+PrintGC  设置打印简要的 GC 日志信息</li> <li>-XX:HandlePromotionFailure  是否设置<code>空间分配担保</code></li></ul> <hr> <p>-XX:HandlePromotionFailure 参数的详细解释：</p> <blockquote><p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p> <ul><li><p>如果大于，则此次Minor GC是安全的</p></li> <li><p>如果小于，则虚拟机会查看<code>-XX:HandlePromotionFailure</code>设置值是否允担保失败。</p></li> <li><ul><li>如果<code>HandlePromotionFailure=true</code>，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li></ul></li> <li><ul><li><ul><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li></ul></li></ul></li> <li><ul><li><ul><li>如果小于，则改为进行一次Full GC。</li></ul></li></ul></li> <li><ul><li>如果<code>HandlePromotionFailure=false</code>，则改为进行一次Full Gc。</li></ul></li></ul> <p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行 Full GC。</p></blockquote> <h2 id="堆是分配对象的唯一选择吗"><a href="#堆是分配对象的唯一选择吗" class="header-anchor">#</a> 堆是分配对象的唯一选择吗？</h2> <blockquote><p>相关问答：<a href="https://www.zhihu.com/question/27963717/answer/38871719" target="_blank" rel="noopener noreferrer">逃逸分析为何不能在编译期进行<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>在《深入理解 Java 虚拟机》中关于堆内存有这样一段描述：</p> <blockquote><p>随着 JIT 编译器的发展和<code>逃逸分析</code>技术逐渐成熟，栈上分配、标量替换等优化技术将会导致一些微妙的变化，使得所有的对象都分配到堆上也渐渐变得不是那么绝对了。</p></blockquote> <p><strong>（1）逃逸分析概述</strong></p> <p>逃逸分析（Escape Analysis）是目前 Java 虚拟机中比较前沿的优化技术。逃逸分析是一项虚拟机通过分析一个对象的动态作用域来决定是否在 Java 堆上分配内存的技术。如果通过逃逸分析发现一个对象不会逃逸到方法外或者线程之外，则编译器（JVM 中的 JIT 编译器 ，即动态编译，而非 javac 这种静态编译）可以为这个对象实例采用不同程度的优化，比如： <code>栈上分配</code>、<code>标量替换</code>、<code>同步消除</code></p> <p>对象的逃逸状态有三种：1、全局逃逸	2、参数逃逸	3、没有逃逸</p> <p><strong>（2）逃逸分析相关参数</strong></p> <ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li> <li>关闭逃逸分析：-XX:+DoEscapeAnalysis</li> <li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul> <blockquote><p>逃逸分析技术在 JavaSE 6u23+ 开始支持，并默认设置为启用状态。</p></blockquote> <p><strong>（3）代码优化之 - 栈上分配</strong></p> <p>在 Java 世界中，对象是在 Java 堆中分配内存的，但是有一种情况，如果经过逃逸分析后，发现一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样的好处是： 无需在堆上分配，也无需进行回收和整理内存。</p> <p><strong>（4）代码优化之 - 标量替换</strong></p> <p>如果一个数据已经无法再分解成更小的数据来表示，那么这些数据就可以被称为标量，比如 Java 中的基本数据类型都是标量。相对的，如果一个数据可以继续分解，那么它就被称为聚合量。Java 中的对象就是典型的聚合量。</p> <p>如果把一个 Java 独享拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为变量替换。</p> <ul><li>开启标量替换：-XX:+EliminateAllocations</li> <li>关闭标量替换：-XX:-EliminateAllocations</li> <li>显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul> <p><strong>（5）代码优化之 - 同步消除</strong></p> <p>线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争。对这个变量实施的同步措施就可以安全的消除掉（移除该对象的同步锁）。</p> <p>同步消除在 JDK8 中都是默认开启的，并且同步消除都要建立在逃逸分析的基础上。</p> <ul><li>开启同步消除：-XX:+EliminateLocks</li> <li>关闭同步消除：-XX:-EliminateLocks</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/jvm/native-method-stack.html" class="prev">
        运行时数据区域之 - 本地方法栈
      </a></span> <span class="next"><a href="/jvm/method-area.html">
        运行时数据区域之 - 方法区
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.fa9b922e.js" defer></script><script src="/assets/js/2.25cc5d58.js" defer></script><script src="/assets/js/43.3f4c39b8.js" defer></script>
  </body>
</html>
