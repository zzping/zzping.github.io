(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{436:function(v,t,a){"use strict";a.r(t);var _=a(45),e=Object(_.a)({},(function(){var v=this,t=v.$createElement,a=v._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"执行引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行引擎"}},[v._v("#")]),v._v(" 执行引擎")]),v._v(" "),a("h2",{attrs:{id:"执行引擎概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行引擎概述"}},[v._v("#")]),v._v(" 执行引擎概述")]),v._v(" "),a("p",[v._v("执行引擎是 Java 虚拟机核心的组成部分之一。")]),v._v(" "),a("p",[v._v("执行引擎 = 解释器 + JIT (Just In Time)编译器 + GC")]),v._v(" "),a("p",[v._v("“虚拟机”是相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎 则是由软件自行实现的，因此可以不受物理条件制约地定制指令集和执行引擎的结构体系，能够执行那些不被硬件支持的指令集格式。")]),v._v(" "),a("p",[v._v("JVM 的主要任务是负责装载字节码到其内部，但是字节码并不能直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅是一些能够被 JVM 所 识别的字节码指令、符号表，以及其他辅助信息。")]),v._v(" "),a("p",[v._v("如果想要让一个 Java 程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM 中的执行引擎 充当了将高级语言翻译为机器语言的译者。")]),v._v(" "),a("h2",{attrs:{id:"解释器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解释器"}},[v._v("#")]),v._v(" 解释器")]),v._v(" "),a("p",[v._v("解释器（Interpreter）： 当 Java 虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容 “翻译” 为对应平台的本地机器指令执行。")]),v._v(" "),a("h2",{attrs:{id:"jit-编译器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jit-编译器"}},[v._v("#")]),v._v(" JIT 编译器")]),v._v(" "),a("p",[v._v("JIT 编译器，也成为即时编译器，指的是在程序运行时为了提高代码的运行效率，虚拟机将一些热点代码直接编译成和本地平台相关的机器语言并缓存在方法区中。这样可以不用逐条解释执行，可以直接从缓存中读取并执行。")]),v._v(" "),a("p",[v._v("HotSpot 虚拟机中内置了多个即时编译器，其中有两个编译器存在已久。分别是：")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("客户端编译器")]),v._v("：Client Compiler，也称为 "),a("code",[v._v("C1 编译器")])]),v._v(" "),a("li",[a("code",[v._v("服务端编译器")]),v._v("：Server Compiler，也称为 "),a("code",[v._v("C2 编译器")])])]),v._v(" "),a("p",[v._v("除了 C1 和 C2 这两个即时编译器，在 JDK10 中又增加了一个 "),a("code",[v._v("Graal 编译器")]),v._v("，它的长久目标是代替 C2 编译器。")]),v._v(" "),a("blockquote",[a("p",[v._v('无论采用的编译器是客户端编译器还是服务端编译器，解释器和编译器搭配使用的方式在虚拟机中被称为"混合模式"（mixed mode）。')])]),v._v(" "),a("h2",{attrs:{id:"编译器的其他说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编译器的其他说明"}},[v._v("#")]),v._v(" 编译器的其他说明")]),v._v(" "),a("ul",[a("li",[v._v("前端编译器： 将 java 源文件编译成 .class 文件，比如 javac。")]),v._v(" "),a("li",[v._v("后端运行期编译器： JIT 编译器，在"),a("code",[v._v("程序运行过程中")]),v._v("将字节码转换为本地机器码并缓存在方法区中。")]),v._v(" "),a("li",[v._v("静态提前编译器： AOT 编译器，在"),a("code",[v._v("程序运行之前")]),v._v("直接把 .java 文件编译成本地机器代码。")])]),v._v(" "),a("h2",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[v._v("#")]),v._v(" 小结")]),v._v(" "),a("p",[v._v("为什么 HotSpot VM 采用解释器 + JIT 编译器并存的架构?")]),v._v(" "),a("p",[v._v("是为了取长补短， 解释器响应时间快， JIT 编译器执行速度快。")])])}),[],!1,null,null,null);t.default=e.exports}}]);