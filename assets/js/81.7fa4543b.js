(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{403:function(t,v,r){"use strict";r.r(v);var e=r(45),a=Object(e.a)({},(function(){var t=this,v=t.$createElement,r=t._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"aop-基本概念和通用术语"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#aop-基本概念和通用术语"}},[t._v("#")]),t._v(" AOP 基本概念和通用术语")]),t._v(" "),r("blockquote",[r("p",[t._v("AOP： Apspect Oriented Programming，面向切面编程")]),t._v(" "),r("p",[t._v("OOP： Object Oriented Programming，面向对象编程")]),t._v(" "),r("hr"),t._v(" "),r("p",[t._v("面向切面编程，基于面向对象编程的基础之上，指的是在程序运行期间，将某段代码动态的切入到指定方法的指定位置进行运行的一种编程方式。")]),t._v(" "),r("p",[r("code",[t._v("AOP 的核心思想： 在不修改原有代码逻辑的基础上实现功能增强。")])]),t._v(" "),r("hr"),t._v(" "),r("p",[r("img",{attrs:{src:"/images/spring/2-aop%E6%9C%AF%E8%AF%AD.png",alt:"aop术语"}})])]),t._v(" "),r("h2",{attrs:{id:"切面-aspect"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#切面-aspect"}},[t._v("#")]),t._v(" 切面（Aspect）")]),t._v(" "),r("blockquote",[r("p",[t._v("切面： 由切入点（Pointcut）和通知（Advice）组成。")]),t._v(" "),r("p",[t._v("在 Spring 中切面通常是一个由 xml 配置表示或者是由注解 @Aspect 标注的类。")])]),t._v(" "),r("h2",{attrs:{id:"连接点-joinpoint"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#连接点-joinpoint"}},[t._v("#")]),t._v(" 连接点（Joinpoint）")]),t._v(" "),r("blockquote",[r("p",[t._v("连接点： 指的是程序执行的某个特定位置。")]),t._v(" "),r("p",[t._v("Spring 仅支持方法的连接点， 包括：")]),t._v(" "),r("ul",[r("li",[t._v("方法调用前")]),t._v(" "),r("li",[t._v("方法调用后")]),t._v(" "),r("li",[t._v("方法抛出异常时")]),t._v(" "),r("li",[t._v("方法调用前后等")])])]),t._v(" "),r("h2",{attrs:{id:"切入点-pointcut"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#切入点-pointcut"}},[t._v("#")]),t._v(" 切入点（Pointcut）")]),t._v(" "),r("blockquote",[r("p",[t._v("切入点： 每个类有多个方法，每个方法又有多个连接点，那些我们感兴趣的、需要切入的点就叫切入点。")]),t._v(" "),r("p",[t._v("在 Spring 中，通过切入点表达式来选择众多连接点中我们需要的切入点。")])]),t._v(" "),r("h2",{attrs:{id:"通知-advice"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#通知-advice"}},[t._v("#")]),t._v(" 通知（Advice）")]),t._v(" "),r("blockquote",[r("p",[t._v("通知： 也叫增强，是目标类连接点上的一段程序代码。")]),t._v(" "),r("p",[t._v("Spring 中总共有 5 种通知类型")]),t._v(" "),r("ul",[r("li",[t._v("前置通知（BeforeAdvice）： 在方法执行之前执行，对应注解 @Before")]),t._v(" "),r("li",[t._v("后置通知（AfterAdvice）： 在方法执行之后执行（无论是否发生异常），无方法结果，对应注解  @After")]),t._v(" "),r("li",[t._v("返回通知（AfterReturningAdvice）： 在方法正常结束并返回结果之后执行，对应注解 @AfterRunning")]),t._v(" "),r("li",[t._v("异常通知（ThrowsAdvice）： 在方法抛出异常之后执行，可以访问异常对象，对应注解 @AfterThrowing")]),t._v(" "),r("li",[t._v("环绕通知（AroundAdvice）： 围绕着整个方法执行，相当于动态代理，对应注解 @Around")])])]),t._v(" "),r("h2",{attrs:{id:"目标对象-target"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#目标对象-target"}},[t._v("#")]),t._v(" 目标对象（Target）")]),t._v(" "),r("blockquote",[r("p",[t._v("目标对象： 具体的业务逻辑类，需要不修改代码而增强逻辑（增加日志、权限处理等）的类")])]),t._v(" "),r("h2",{attrs:{id:"代理对象-proxy"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#代理对象-proxy"}},[t._v("#")]),t._v(" 代理对象（Proxy）")]),t._v(" "),r("blockquote",[r("p",[t._v("代理对象  =  目标对象 + AOP 逻辑（增强逻辑）")]),t._v(" "),r("p",[t._v("代理对象： 既可能是和原类具有相同接口的类，也可能是原类的子类。所以可以采用与调用原类相同的方法调用代理类。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);