(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{408:function(a,t,n){"use strict";n.r(t);var s=n(45),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"lambda-表达式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#lambda-表达式"}},[a._v("#")]),a._v(" Lambda 表达式")]),a._v(" "),n("h2",{attrs:{id:"lambda-表达式简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#lambda-表达式简介"}},[a._v("#")]),a._v(" Lambda 表达式简介")]),a._v(" "),n("p",[a._v("（1）Lambda 是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到提升。Lambda实际上就是一种“语法糖”或者叫“糖语法”，底层实际上就是封装了一个方法方便我们书写使用，让代码更少，写起来更加方便。")]),a._v(" "),n("p",[a._v("（2）Lambda 表达式是一个匿名方法，将行为像数据一样进行传递。所谓的 Lambda 表达式实际上就是对接口的实现，java8 之前我们是通过匿名内部类实现接口。java8 开始我们就可以使用 Lambda 表达式来实现接口。所以 Lambda 需要函数式接口的支持。")]),a._v(" "),n("p",[a._v('（3）Lambda 表达式的基础语法： Java8 中引入了一个新的操作符 "->" 该操作符称为箭头操作符或者 Lambda 操作符。箭头操作符将 Lambda 表达式拆分成两部分：')]),a._v(" "),n("ul",[n("li",[a._v("左侧：参数列表     ==》  对应的是接口中的抽象方法的参数列表。")]),a._v(" "),n("li",[a._v("右侧：Lambda 体   ==》  对应的是接口中的抽象方法要实现的功能。")])]),a._v(" "),n("h2",{attrs:{id:"lambda-表达式的几种语法格式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#lambda-表达式的几种语法格式"}},[a._v("#")]),a._v(" Lambda 表达式的几种语法格式")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('(1)语法格式一：无参数，无返回值【Runnable 接口】\n \t\t () -> System.out.println("Hello Lambda!");\n            \n \n(2)语法格式二：有一个参数，并且无返回值【Java8 新增的一个接口 Consumer, 】\n \t\t(x) -> System.out.println(x)\n\n(3)语法格式三：若只有一个参数，小括号可以省略不写\n \t\tx -> System.out.println(x)\n \n(4)语法格式四：有两个以上的参数，有返回值，并且 Lambda 体中有多条语句【Comparator 接口】\n\t\tComparator<Integer> com = (x, y) -> {\n\t\tSystem.out.println("函数式接口");\n\t\t\treturn Integer.compare(x, y);\n\t\t};\n\n(5)语法格式五：若 Lambda 体中只有一条语句， return 和 大括号都可以省略不写\n\t\tComparator<Integer> com = (x, y) -> Integer.compare(x, y);\n\n(6)语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”\n\t\t(Integer x, Integer y) -> Integer.compare(x, y);\n')])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br"),n("span",{staticClass:"line-number"},[a._v("20")]),n("br"),n("span",{staticClass:"line-number"},[a._v("21")]),n("br")])])])}),[],!1,null,null,null);t.default=e.exports}}]);