(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{418:function(e,r,t){"use strict";t.r(r);var a=t(45),n=Object(a.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"docker-网络"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#docker-网络"}},[e._v("#")]),e._v(" Docker 网络")]),e._v(" "),t("p",[e._v("官方文档： "),t("a",{attrs:{href:"https://docs.docker.com/network/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Configure networking"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。")]),e._v(" "),t("p",[e._v("Docker 中的网络通信是通过驱动程序完成的，默认的 Docker 提供了几种驱动程序：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("bridge")]),e._v("： 默认的网络驱动。")]),e._v(" "),t("li",[t("code",[e._v("host")])]),e._v(" "),t("li",[t("code",[e._v("overlay")])]),e._v(" "),t("li",[t("code",[e._v("macvlan")])]),e._v(" "),t("li",[t("code",[e._v("none")])])]),e._v(" "),t("p",[e._v("Docker 在 1.9 版本中引入了一整套的 "),t("code",[e._v("docker network")]),e._v(" 子命令和跨主机网络支持。")]),e._v(" "),t("blockquote",[t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("查看所有的网络\n\tdocker network ls\n\n# 默认有三个网络\nNETWORK ID          NAME                DRIVER              SCOPE\na1c4959cf71d        bridge              bridge              local\n60b9c35f74ce        host                host                local\n1d81bf674d88        none                null                local\n\n\n创建一个网络\n\tdocker network create\n\n查看网络的细节\n\tdocker network inspect\n\n删除指定的网络\n\tdocker network rm\n\n删除所有未使用的网络\n\tdocker network prune\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br"),t("span",{staticClass:"line-number"},[e._v("12")]),t("br"),t("span",{staticClass:"line-number"},[e._v("13")]),t("br"),t("span",{staticClass:"line-number"},[e._v("14")]),t("br"),t("span",{staticClass:"line-number"},[e._v("15")]),t("br"),t("span",{staticClass:"line-number"},[e._v("16")]),t("br"),t("span",{staticClass:"line-number"},[e._v("17")]),t("br"),t("span",{staticClass:"line-number"},[e._v("18")]),t("br"),t("span",{staticClass:"line-number"},[e._v("19")]),t("br"),t("span",{staticClass:"line-number"},[e._v("20")]),t("br"),t("span",{staticClass:"line-number"},[e._v("21")]),t("br")])])]),e._v(" "),t("h2",{attrs:{id:"bridge-驱动-桥接模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bridge-驱动-桥接模式"}},[e._v("#")]),e._v(" bridge 驱动（桥接模式）")]),e._v(" "),t("p",[e._v("bridge 是 docker 默认的网络驱动，使用该驱动时，运行的 docker 容器会连接到 docker 网桥上。")]),e._v(" "),t("blockquote",[t("p",[e._v("（1）docker 在启动的时候，会自动创建一个默认的网桥（网桥的名字就叫 bridge），在运行容器的时候如果没有特殊指定网络选项（"),t("code",[e._v("--network 或者 --net")]),e._v("），该容器将会连接到 bridge 网络上。用户还可以创建自定义的网桥网络，用户自定义的网桥网络会优于默认的 bridge 网络。")]),e._v(" "),t("p",[e._v("（2）在 docker 中，bridge 模式下网络使用软件网桥。该网桥允许连接到统一网桥上的容器进行互相通信，同时与未连接到该网桥上的容器进行隔离。docker 的 bridge 驱动会自动的在宿主机上 install rules，所以这就是为什么不同网桥上的容器之间无法进行相互通信。")]),e._v(" "),t("blockquote",[t("p",[e._v("Tips： 在网络方面，桥接网络是在网段之间转发流量的链路层设备。桥接器可以是在主机内核中运行的硬件设备或软件设备。")])]),e._v(" "),t("p",[e._v("（3）bridge 网络适用于在同一 docker 守护程序主机上运行的容器。对于在不同 docker 守护程序主机上运行的容器之间进行通信，您可以在OS级别管理路由，或者使用 overlay 网络模式。")]),e._v(" "),t("p",[e._v("（4）brige 模式已经基本上可以满足 docker 容器最基本的使用需求了。但是这种模式和外界通信使用 NAT（网络地址转换），增加了通信的复杂性，在复杂场景下使用会有诸多限制。")])]),e._v(" "),t("h3",{attrs:{id:"使用默认的网桥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用默认的网桥"}},[e._v("#")]),e._v(" 使用默认的网桥")]),e._v(" "),t("blockquote",[t("p",[e._v("官方文档： "),t("a",{attrs:{href:"https://docs.docker.com/network/network-tutorial-standalone/#use-the-default-bridge-network",target:"_blank",rel:"noopener noreferrer"}},[e._v("使用默认网桥"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("（1）查看 docker 网络列表： docker network ls")]),e._v(" "),t("p",[e._v("（2）默认启动一个容器没有指定网络就是使用默认的 bridge 网桥")]),e._v(" "),t("blockquote",[t("p",[e._v("docker run -p 8080:8080 --name tomcat01 -d tomcat:8.0.52")])])]),e._v(" "),t("h3",{attrs:{id:"使用自定义的网桥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用自定义的网桥"}},[e._v("#")]),e._v(" 使用自定义的网桥")]),e._v(" "),t("blockquote",[t("p",[e._v("官方文档：  "),t("a",{attrs:{href:"https://docs.docker.com/network/network-tutorial-standalone/#use-the-default-bridge-network",target:"_blank",rel:"noopener noreferrer"}},[e._v("使用自定义网桥"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("（1）查看 docker 网络列表： docker network ls")]),e._v(" "),t("p",[e._v("（2）创建自定义的 bridge 网络： docker network  my_network01")]),e._v(" "),t("blockquote",[t("p",[t("code",[e._v("可以通过 -d 选项指定网络类型，默认不指定的话就是 bridge")])])]),e._v(" "),t("p",[e._v("（3）运行容器并指定使用自定义网桥 my_network01")]),e._v(" "),t("blockquote",[t("p",[e._v("docker run -p 8081:8080 --net my_network01 -d --name tomcat02 tomcat:8.0.52")])]),e._v(" "),t("blockquote",[t("p",[t("code",[e._v("可以通过 --network 或者 --net 选项指定自定义的网络")])])]),e._v(" "),t("blockquote",[t("p",[e._v("注意： 使用 --network 或者 --net 指定一个网络的时候，该网络必须已经先创建好了")])]),e._v(" "),t("p",[e._v("（4）查看自定义的网桥细节： docker network inspect my_network01")]),e._v(" "),t("p",[e._v("（5）其他：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("一旦在启动容器时指定了网桥之后，日后可以在任何这个网桥关联的容器中使用容器名字与其他容器进行通信。使用默认的 bridge 这个网桥无法使用名字，必须要是自定义的网桥才可以。\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])])]),e._v(" "),t("h3",{attrs:{id:"默认网桥-vs-自定义网桥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#默认网桥-vs-自定义网桥"}},[e._v("#")]),e._v(" 默认网桥 VS 自定义网桥")]),e._v(" "),t("blockquote",[t("p",[e._v("官方文档： "),t("a",{attrs:{href:"https://docs.docker.com/network/bridge/#differences-between-user-defined-bridges-and-the-default-bridge",target:"_blank",rel:"noopener noreferrer"}},[e._v("默认网桥 VS 自定义网桥"),t("OutboundLink")],1)])]),e._v(" "),t("h3",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[t("code",[e._v("总结")]),e._v("："),t("code",[e._v("bridge 模式适用于单个 Docker 主机的场景，并且当一个 Docker 主机中运行多个容器时，最好是使用自定义的网桥，把相关联的容器连接到自定义的网桥上")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"host-驱动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#host-驱动"}},[e._v("#")]),e._v(" host 驱动")]),e._v(" "),t("blockquote",[t("p",[e._v("（1）使用这种驱动的时候，libnetwork 将不会为 docker 容器创建网络协议栈，即不会创建独立的 network namespace。")]),e._v(" "),t("p",[e._v("（2）docker 容器中的京城处于宿主机的网络环境中，相当于 docker 容器和宿主机共用一个 network namespace，使用宿主机的网卡、IP 和端口等信息。但是容器其他方面，如文件系统、进程列表等还是和宿主机隔离的。")]),e._v(" "),t("p",[e._v("（3）host 模式很好的解决了容器与外界通信的地址转换问题，可以直接使用宿主机的 IP 进行同i性能，不存在虚拟化网络带来的额外性能负担。但是 host 驱动也降低了容器与容器之间、容器与宿主机之间的网络层面的隔离，引起网络资源的竞争与冲突。因此 host 驱动使用了对容器集群规模不大的场景。")])]),e._v(" "),t("h2",{attrs:{id:"overlay-驱动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#overlay-驱动"}},[e._v("#")]),e._v(" overlay 驱动")]),e._v(" "),t("blockquote",[t("p",[e._v("此驱动采用 IETF 标准的 VXLAN 方式，并且是 VXLAN 中最普遍认为最适合大规模的云计算虚拟化环境的 SDN controller 模式。在使用的过程中，需要一个额外的存储配置服务，例如 Consul、etcd 或者 Zookeeper 。还需要在启动 docker daemon 的时候额外添加参数来指定所使用的配置存储服务地址。")]),e._v(" "),t("p",[t("code",[e._v("overlay 适用于多主机 Docker（集群服务）")])]),e._v(" "),t("p",[t("code",[e._v("官方文档")]),e._v("： "),t("a",{attrs:{href:"https://docs.docker.com/network/network-tutorial-overlay/",target:"_blank",rel:"noopener noreferrer"}},[e._v("集群服务下使用 overlay 驱动"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"macvlan-驱动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#macvlan-驱动"}},[e._v("#")]),e._v(" macvlan 驱动")]),e._v(" "),t("blockquote",[t("p",[e._v("Macvlan网络允许您将MAC地址分配给容器，使其在网络上显示为物理设备。 Docker守护程序通过其MAC地址将流量路由到容器。 在处理希望直接连接到物理网络而不是通过Docker主机的网络堆栈进行路由的旧应用程序时，使用macvlan驱动程序有时是最佳选择。")])]),e._v(" "),t("h2",{attrs:{id:"none-驱动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#none-驱动"}},[e._v("#")]),e._v(" none 驱动")]),e._v(" "),t("blockquote",[t("p",[e._v("使用这种驱动的时候，docker 容器禁用所有网络，通常与自定义网络驱动程序一起使用。")])]),e._v(" "),t("h2",{attrs:{id:"几种网络模式的总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#几种网络模式的总结"}},[e._v("#")]),e._v(" 几种网络模式的总结")]),e._v(" "),t("blockquote",[t("p",[e._v("（1）单主机 Docker 推荐使用 bridge 模式， 该模式也是 Docker 默认的网络模式。")]),e._v(" "),t("p",[e._v("（2）集群下推荐使用 overlay 模式")]),e._v(" "),t("p",[e._v("（3）自定义网络驱动下，配合 none 模式。")])])])}),[],!1,null,null,null);r.default=n.exports}}]);