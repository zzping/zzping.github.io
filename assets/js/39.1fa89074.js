(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{437:function(v,_,a){"use strict";a.r(_);var t=a(45),e=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"垃圾回收相关算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收相关算法"}},[v._v("#")]),v._v(" 垃圾回收相关算法")]),v._v(" "),a("p",[v._v("进行 GC 之前，首先需要判断哪些对象是垃圾，这是标记阶段要做的事情。")]),v._v(" "),a("p",[v._v("判断对象是否是垃圾对象一般有两种方式："),a("code",[v._v("引用计数算法")]),v._v("、"),a("code",[v._v("可达性分析算法")])]),v._v(" "),a("h2",{attrs:{id:"标记阶段-引用计数算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记阶段-引用计数算法"}},[v._v("#")]),v._v(" 标记阶段 - 引用计数算法")]),v._v(" "),a("p",[v._v("引用计数算法是用来判断一个对象是否是垃圾的一种算法，它指的是每个对象都有一个引用计数器，当有引用指向它时，计数器加一，引用失效时，计数器减一。任何时刻只要一个对象的引用计数器的值为0就表示该对象是一个垃圾。")]),v._v(" "),a("p",[v._v("优点：实现简单，垃圾对象便于识别。")]),v._v(" "),a("p",[v._v("缺点：")]),v._v(" "),a("ul",[a("li",[v._v("每个对象都需要空间存储引用计数器的值，增加了空间消耗。")]),v._v(" "),a("li",[v._v("没有新增或减少引用都需要更新引用计数器的值，增加了时间开销。")]),v._v(" "),a("li",[v._v("无法处理循环引用的情况，最严重的问题。")])]),v._v(" "),a("blockquote",[a("p",[v._v("目前主流的 Java 虚拟机都没有采用引用计数算法来判定一个对象是否存活，而是通过另外一种算法 - "),a("code",[v._v("可达性分析算法")])])]),v._v(" "),a("h2",{attrs:{id:"标记阶段-可达性分析算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记阶段-可达性分析算法"}},[v._v("#")]),v._v(" 标记阶段 - 可达性分析算法")]),v._v(" "),a("p",[v._v("当前主流的商用程序语言（Java、C#）的内存管理子系统都是通过"),a("code",[v._v("可达性分析算法")]),v._v("来判断对象是否存活的。")]),v._v(" "),a("p",[v._v("可达性分析算法指的是通过一系列称为"),a("code",[v._v("GC Roots")]),v._v('的根对象作为起始节点，根据引用关系进行向下搜索，搜索走过的路径称为 "引用链"，如果一个对象到 GC Roots 之间没有任何引用链相连，则证明这个对象是不可达的，即这个对象是已经死亡可以回收的对象。')]),v._v(" "),a("p",[a("a",{attrs:{href:"https://www.zhihu.com/question/29218534",target:"_blank",rel:"noopener noreferrer"}},[v._v("为什么可达性分析算法不会出现循环引用的问题？"),a("OutboundLink")],1)]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/jvm/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png",alt:"可达性分析算法"}})]),v._v(" "),a("h2",{attrs:{id:"对象的-finalization-机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的-finalization-机制"}},[v._v("#")]),v._v(" 对象的 finalization 机制")]),v._v(" "),a("p",[v._v("Java 语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。类似生命周期函数、钩子函数的概念。这种机制对应的是 Object 类中的 finalize 方法。")]),v._v(" "),a("p",[v._v("finalize() 方法是定义在 Object 类中, 是一个 protected 方法，允许子类重写该方法。用于对象被回收时进行资源释放的一些工作。对象可以在 finalize 方法中复活。")]),v._v(" "),a("p",[v._v('在通过可达性分析算法后，如果判定了一个对象是不可达的。也并不意味着这个对象就 "非死不可"，这时这个对象实际上还处于 "缓刑" 阶段。一个对象要真正死亡，至少要经历两次标记过程。')]),v._v(" "),a("ul",[a("li",[v._v("第一次标记：如果对象在进行可达性分析后发现没有与 GC Root 相连的引用链时，会被第一次标记。")]),v._v(" "),a("li",[v._v("第二次标记：会进行一次筛选，判定此对象是否有必要执行 finalize() 方法")])]),v._v(" "),a("p",[v._v("由于 finalize() 方法的存在，虚拟机中的对象一般有三种可能的状态")]),v._v(" "),a("p",[v._v("（1） 可触及的： 从根节点开始，可以到达这个对象")]),v._v(" "),a("p",[v._v("（2）可复活的： 对象的所有引用都被释放，但是对象有可能在 finalize() 方法中复活")]),v._v(" "),a("p",[v._v("（3）不可触及的： 对象的 finalize() 被调用并且没有复活。finalize 方法只会被调用一次")]),v._v(" "),a("h2",{attrs:{id:"标记-清除算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记-清除算法"}},[v._v("#")]),v._v(" 标记 - 清除算法")]),v._v(" "),a("p",[a("code",[v._v("标记-清除（Mark-Sweep）算法")]),v._v("是最早出现也是最基础的垃圾收集算法，是在 1960 年由 Lisp 之父 John McCarthy 所提出。该算法分为 "),a("code",[v._v("标记")]),v._v("和"),a("code",[v._v("清除")]),v._v("两个阶段：")]),v._v(" "),a("ul",[a("li",[v._v("标记阶段：通过可达性分析算法标记出所有需要不可达的对象。")]),v._v(" "),a("li",[v._v("清除阶段：统一回收掉所有被标记的不可达对象。")])]),v._v(" "),a("p",[v._v("标记 - 清除算法实现简单，但是有两个主要的缺点：")]),v._v(" "),a("p",[v._v("（1）如果 Java 堆中有大量对象，需要进行大量标记和清除，效率比较低。")]),v._v(" "),a("p",[v._v("（2）清除之后会产生大量不连续的"),a("code",[v._v("内存碎片")]),v._v("。可能会导致后续需要分配大对象时而无法找到连续的内存空间，进而不得不提前触发一次垃圾收集的动作。")]),v._v(" "),a("h2",{attrs:{id:"复制算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复制算法"}},[v._v("#")]),v._v(" 复制算法")]),v._v(" "),a("p",[v._v("复制算法是标记 - 复制算法的简称，是为了解决标记 - 清除算法中的缺点而诞生的，复制算法的核心思想是通过将内存空间分成大小相等的两半。每次分配内存只使用其中的一块空间。当这一块空间使用完了，就将还存活的对象复制到另一块空间中去。然后再把已经使用的内存空间一次清理掉。这样就解决了在标记 - 清除算法中如果有大量垃圾对象时候清除效率低的问，同时由于每次都是针对半区进行内存回收，也不会出现内存碎片的问题。")]),v._v(" "),a("p",[v._v("但是复制算法仍然有自己的缺点：可用内存变为了原来的一半。造成了大量的内存空间浪费，但是实际上 HotSpot 虚拟机中默认新生代和老年代 1:2，然后新生代中 Eden：S0：S1 = 8：1：1，通过这样的分配。实际上只有占堆空间 1/30 的大小在每次分配时不会被用到。")]),v._v(" "),a("blockquote",[a("p",[v._v("复制算法适合新生代区，因为新生代对象大多数朝生夕死，存活下来的很少，这样复制的工作量就会很少。")])]),v._v(" "),a("h2",{attrs:{id:"标记-整理算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记-整理算法"}},[v._v("#")]),v._v(" 标记 - 整理算法")]),v._v(" "),a("p",[v._v("前面复制算法的高效是建立在存活的对象少的前提下（这种情况在新生代经常发生），但是当存活对象比较多时（比如老年代），就需要很多的复制操作，效率将会降低。极端情况下，所有对象都是可达对象，此使再使用复制算法效率就会很低。")]),v._v(" "),a("p",[v._v("针对老年代的对象存亡特征，又有人提出了一种新的算法： 标记 - 整理（Mark - Compact）算法。")]),v._v(" "),a("p",[v._v("标记 - 整理算法也是分为了标记和整理两个阶段，标记阶段和标记 - 清除算法一样，只不过整理阶段不是对不可达对象进行回收，而是将所有存活的对象都向内存空间的一边进行移动，然后直接清理掉这一边以外的内存空间。这样回收后的内存空间仍然是连续的，不会有内存碎片的问题。")]),v._v(" "),a("h2",{attrs:{id:"分代收集算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分代收集算法"}},[v._v("#")]),v._v(" 分代收集算法")]),v._v(" "),a("p",[v._v("分代收集算法不属于一种具体的算法实现，而是从内存的角度，在不同的区域（新生代、老年代）使用不同的垃圾收集算法的一种说法。")]),v._v(" "),a("ul",[a("li",[v._v("新生代： 复制算法")]),v._v(" "),a("li",[v._v("老年代：标记 - 清楚算法、标记复制算法")])]),v._v(" "),a("h2",{attrs:{id:"分区算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分区算法"}},[v._v("#")]),v._v(" 分区算法")]),v._v(" "),a("p",[v._v("分区算法是针对于 G1 这块垃圾收集器来说的。主要也是为了解决 gc 停顿时间长造成用户体验差的问题。")]),v._v(" "),a("p",[v._v("基本思想是： 一般来说，在相同条件下，堆空间越大，一次 GC 所需要的时间就越长，有关 GC 产生的停顿也就越长。为了更好的控制 GC 产生的停顿时间。将一块大的内存区域分割成多个 小块，根据目标的停顿时间，每次合理的回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。")]),v._v(" "),a("p",[v._v("【分代算法和分区算法的区别】")]),v._v(" "),a("ul",[a("li",[v._v("分代算法： 按对象的生命周期长短分成两个部分")]),v._v(" "),a("li",[v._v("分区算法： 将整个堆空间分成多个连续的小区间【region】，每个小区间都独立使用、独立回收。这种算法好处是可以控制一次回收多个小区间")])])])}),[],!1,null,null,null);_.default=e.exports}}]);