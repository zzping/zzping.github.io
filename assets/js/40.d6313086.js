(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{439:function(a,t,s){"use strict";s.r(t);var e=s(45),n=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"垃圾回收相关概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收相关概念"}},[a._v("#")]),a._v(" 垃圾回收相关概念")]),a._v(" "),s("h2",{attrs:{id:"对-system-gc-的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对-system-gc-的理解"}},[a._v("#")]),a._v(" 对 System.gc() 的理解")]),a._v(" "),s("p",[a._v("System.gc() 是 Java 提供的一个用于手动调用 gc 的 API，用于显示的告诉垃圾收集器进行 Full GC，同时对新生代和老年代进行回收，尝试释放不可达的对象所占用的内存。")]),a._v(" "),s("p",[a._v("System.gc() 实际上还是调用的 Runtime.getRuntime().gc()。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("gc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Runtime")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getRuntime")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("gc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("p",[a._v("关于 System.gc() 方法什么时候会执行 GC 要分两个层面来解释：")]),a._v(" "),s("p",[s("strong",[a._v("（1）规范层面")]),a._v("：JVM规范没规定实现要使用怎样的自动内存管理；Java的标准库API里System.gc()的规定说它只是一个提示，不保证有什么作用或者何时起作用。甚至可能不进行 GC 也可以。")]),a._v(" "),s("p",[s("strong",[a._v("（2）实现层面")]),a._v("： HotSpot VM和很多其它JVM一样，其实默认是会在用户调用System.gc()的时候马上执行GC，并且等到GC完成才返回的。只有使用CMS或G1时，配置-XX:+ExplicitGCInvokesConcurrent，调用System.gc()才会在触发了并发GC后就返回。其中CMS版跟G1版的行为还略微不一样。")]),a._v(" "),s("h2",{attrs:{id:"内存溢出与内存泄漏"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存溢出与内存泄漏"}},[a._v("#")]),a._v(" 内存溢出与内存泄漏")]),a._v(" "),s("p",[a._v("内存溢出（Out Of Memory，OOM）： 程序在申请内存时，没有足够的空闲内存，并且垃圾收集器也无法提供更多的内存，则就会出现 OOM。大多数情况下，在内存溢出（OOM）之前都会先进行一次 Full GC， 进行完 Full GC 之后发现内存还是不够就会发生内存溢出。")]),a._v(" "),s("p",[a._v("内存泄漏（Memory Leak）可以从两个层面来解释：")]),a._v(" "),s("ul",[s("li",[a._v("严格来讲：对象不会再被程序中用到了，但是 GC 又无法回收他们的情况，才叫内存泄漏。")]),a._v(" "),s("li",[a._v("广义上来讲：一些不太好的代码实践会导致对象的生命周期变得很长最后导致 OOM，也可以叫做内存泄漏。")])]),a._v(" "),s("p",[a._v("内存泄漏举例：")]),a._v(" "),s("ul",[s("li",[a._v("一些连接资源没有关闭： 数据库连接、网络连接等要手动 close")]),a._v(" "),s("li",[a._v("ThreadLocal 的使用")])]),a._v(" "),s("h2",{attrs:{id:"stop-the-world"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stop-the-world"}},[a._v("#")]),a._v(" Stop The World")]),a._v(" "),s("p",[a._v("Stop-The-World 简称 STW，指的是 GC 时间发生过程中，会产生影响程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为 STW。")]),a._v(" "),s("p",[a._v("可达性分析算法中枚举根节点（GC Roots）会导致所有 Java 执行线程停顿")]),a._v(" "),s("p",[a._v("（1）分析工作必须在一个能确保一致性的快照中进行")]),a._v(" "),s("p",[a._v("（2）一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上")]),a._v(" "),s("p",[a._v("（3）如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证")]),a._v(" "),s("p",[a._v("STW 事件和用哪款 GC 无关，所有的垃圾收集器都会有 STW，即使是最优秀的 G1 也无法避免，只能是尽可能的缩短 STW 的时间。")]),a._v(" "),s("h2",{attrs:{id:"垃圾回收的并行与并发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收的并行与并发"}},[a._v("#")]),a._v(" 垃圾回收的并行与并发")]),a._v(" "),s("p",[a._v("（1）程序的并行和并发")]),a._v(" "),s("ul",[s("li",[a._v("并发：单个 CPU（单核）上，在一段时间内，多个线程通过CPU时间片快速切换。")]),a._v(" "),s("li",[a._v("并行：多个 CPU 或者单个CPU（多核），不同的核同时执行不同的线程，互不抢占资源。")])]),a._v(" "),s("p",[a._v("只有在多 CPU 或者一个 CPU 多核的情况下，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。")]),a._v(" "),s("p",[a._v("（2）垃圾回收的并行和并发")]),a._v(" "),s("p",[a._v("垃圾回收的并行：")]),a._v(" "),s("ul",[s("li",[a._v("串行： 单个垃圾线程执行")]),a._v(" "),s("li",[a._v("并行： 多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态")])]),a._v(" "),s("p",[a._v("垃圾回收的并发：指的是用户线程和垃圾收集线程同时执行（但不一定是并行的，可能会交替执行，垃圾回收线程在执行时不会停顿用户程序的运行）。如 CMS、G1 用户程序在继续执行，而垃圾收集程序线程运行于另一个 CPU 上。")]),a._v(" "),s("h2",{attrs:{id:"安全点和安全区域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#安全点和安全区域"}},[a._v("#")]),a._v(" 安全点和安全区域")]),a._v(" "),s("p",[s("strong",[a._v("安全点")]),a._v("： 程序执行时并不是在所有地方都能停顿下来开始 GC，只有在特定的位置才能停顿下来开始 GC，这些位置称为 “安全点”。")]),a._v(" "),s("p",[a._v("如何在发生 GC 时，让所有线程都跑在最近的安全点停顿下来呢？")]),a._v(" "),s("p",[a._v("（1）抢占式中断： 首先中断所有线程，如果还有线程不在安全点，就恢复线程，让线程跑到安全点。（目前没有虚拟机采用了）")]),a._v(" "),s("p",[a._v("（2）主动式中断： 设置一个中断标志，各个线程运行到安全点的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。")]),a._v(" "),s("p",[s("strong",[a._v("安全区域")]),a._v("：是指一段代码片段中，对象的引用关系不会发生变化，在这个区域的任何位置开始 GC 都是安全的。可以把安全区域看成是扩展了的安全点。")]),a._v(" "),s("h2",{attrs:{id:"java-中的四种引用-强软弱虚"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-中的四种引用-强软弱虚"}},[a._v("#")]),a._v(" Java 中的四种引用 - 强软弱虚")]),a._v(" "),s("p",[a._v("在 JDK1.2 之后, Java 对引用的概念进行了扩充, 将引用分为了 4 种, 这四次引用强度依次减弱：")]),a._v(" "),s("ul",[s("li",[a._v("强引用： Strong Reference")]),a._v(" "),s("li",[a._v("软引用： Soft Reference")]),a._v(" "),s("li",[a._v("弱引用： Weak Reference")]),a._v(" "),s("li",[a._v("虚引用： Phantom Reference")])]),a._v(" "),s("p",[a._v("引用相关的 API 如下：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("java"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("lang"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("ref"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")])]),a._v("Reference")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" 抽象类\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("java"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("lang"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("ref"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")])]),a._v("SoftReference")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" 软引用，内存不足则回收\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("java"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("lang"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("ref"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")])]),a._v("WeakReference")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" 弱引用，只要垃圾收集器工作就回收，不管内存是否足够\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("java"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("lang"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("ref"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")])]),a._v("PhantomReference")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" 虚引用\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("java"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("lang"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("ref"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")])]),a._v("FinalReference")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" 终结器引用\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("p",[s("strong",[a._v("（1）强引用")])]),a._v(" "),s("p",[a._v("强引用是最常见的引用类型，指的是程序中普遍存在的引用赋值，类似： Object obj = new Object() 这种引用关系。无论任何情况下，只要强引用的关系还存在，垃圾收集器就永远不会回收掉被引用的对象。")]),a._v(" "),s("p",[s("strong",[a._v("（2）软引用")])]),a._v(" "),s("p",[a._v("软引用的关系用来描述一些还有用，但是非必须的对象。在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收。，如果这次回收还没有足够的内存，才会抛出内存溢出异常。")]),a._v(" "),s("p",[s("strong",[a._v("（3）弱引用")])]),a._v(" "),s("p",[a._v("弱引用也是用来描述那些非必须的对象，但是它的强度比软引用要弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生为止。只要垃圾收集器开始工作，不管内存是否足够都会回收只有弱引用关联的对象。")]),a._v(" "),s("p",[s("strong",[a._v("（4）虚引用")])]),a._v(" "),s("p",[a._v("虚引用是最弱的一种引用关系，一个对象是否有虚引用存在，完全不会对其生存时间构成影响。也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能够在这个对象被垃圾收集器回收时收到一个系统通知。")])])}),[],!1,null,null,null);t.default=n.exports}}]);